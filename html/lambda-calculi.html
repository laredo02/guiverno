<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Miguel Laredo Barbadillo</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css" rel="stylesheet"/>
    <link rel="stylesheet" href="../style/style.css">
  </head>
  <meta name="Miguel Laredo Barbadillo" content="Miguel Laredo Barbadillo">
  <body style="font-family: 'Georgia', serif; max-width: 1200px; margin: 0 auto; padding: 20px; line-height: 1.6; text-align: justify; color: #000;">
    <h2 style="text-align: center;">Cálculo lambda</h2>
    <p>
      El <a href="https://en.wikipedia.org/wiki/Lambda_calculus">cálculo lambda</a> es el modelo computacional que sienta los cimientos de lo que son las funciones en su sentido más abstracto, además, establece nociones muy interesantes sobre equivalencia de funciones. En lo siguiente, presento una implementación sencilla de un interprete de <a href="https://en.wikipedia.org/wiki/Lambda_calculus">cálculo lambda</a> escrito en <a href="    https://www.haskell.org/">Haskell</a>, el próposito es programar un poco mientras escribo el trabajo de fin de máster, además me ayudará a simplificar ecuaciones y sacar resultados más rápidamente. Será interesante ver si puedo calcular ejemplos de algunos de los teoremas relevantes, como la propiedad de <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem">Church-Rosser</a>.
    </p>
    <p>
      Si quieres saber más sobre <a href="https://www.haskell.org/">Haskell</a>, o llevar a cabo algun proyecto similar, te lo puedes descargar <a href="https://www.haskell.org/downloads/">aquí</a>. Por otro lado, un buen recurso para cálculo lambda y <i>proof theory</i>, es <a href="https://www.cambridge.org/core/books/type-theory-and-formal-proof/0472640AAD34E045C7F140B46A57A67C#"><i>Type Theory and Formal Proof: An Introduction</i></a>, de Rob Nederpelt Herman Geuvers. Habla sobre tipado y demostraciones formales, es un buen libro, bastante accesible excepto por el precio. Este <a href="https://anggtwu.net/tmp/nederpelt_geuvers__type_theory_and_formal_proof_an_introduction.pdf">link</a> no es un enlace a un <i>.pdf</i> del libro.
    </p>
    <h2 style="text-align: center;">Cálculo Lambda no Tipado</h2>
    <p>
      Todos los términos o lambda términos que forman parte del lenguaje del <a href="https://en.wikipedia.org/wiki/Lambda_calculus">cálculo lambda</a> se producen a través de la siguiente gramática:
    </p>
    <p>
      \[
      M ::= x \mid (\lambda x. M) \mid (M \ N)
      \]
    </p>
    <p>
      donde:
    </p>
    <ul>
      <li>\( x \) es un parámetro.</li>
      <li>\( \lambda x. M \) representa una abstracción lambda, una función que captura \( x \) en \( M \), de forma equivalente: \(x\) es un parámetro que se utiliza dentro de \(M\). Mediante la operación de aplicación, podemos dar valores concretos a \(x\) y evaluar \(M\).</li>
      <li>\( M \; N \) significa aplicación, es decir, aplicación de la función \( M \) al argumento \( N \). Ambos, \( M \) y \( N \), son términos lambda.</li>
    </ul>
    <p>
      Lo anterior, lo podemos implementar en <a href="https://www.haskell.org/">Haskell</a> utilizando <a href="https://wiki.haskell.org/index.php?title=Algebraic_data_type">tipos algebraicos</a>. Ya que nos permiten traducir la gramatica literalemente, lo cual facilita mucho el trabajo:
    </p>
    <pre><code class="language-haskell">data LambdaTerm = Var String
	| Abs String LambdaTerm
	| App LambdaTerm LambdaTerm</code></pre>
    <p>
      Para mostrar las expresiones lambda que definamos dentro del programa, se puede por ejemplo, declarar una función <code>showTerm</code>, que devuelva un string con la representación del término, y luego otra función (<code>putTerm</code>) no pura que imprima el string por pantalla: 
    </p>
    <pre><code class="language-haskell">showTerm :: Term -> String
showTerm (Var s) = s
showTerm (Abs s t) = "(λ" ++ s ++ "." ++ showTerm t ++ ")"
showTerm (App t1 t2) = (showTerm t1) ++ (showTerm t2)

putTerm :: Term -> IO()
putTerm t = putStrLn (showTerm t)</code></pre>
    <p>
      Ahora, desde la consola interactiva de <a href="    https://www.haskell.org/">Haskell</a>, es posible hacer lo siguiente:
    </p>
    <pre><code class="language-haskell">ghci> term = ((App (Abs "x" (App (Var "x") (Var "x"))) (Var "y")))
ghci> putTerm term
(λx.xx)y</code></pre>
    <p>
      de forma que podemos interpretar las expresiones lambda igual que lo haríamos en papel. Con estas utilidades básicas en orden, toca empezar a definir funciones para operar sobre termnos, empezamos con el cálculo del conjunto de variables libres, es decir, las variables que forman parte de una expresión lambda, y que no están capturadas por ninguna abstracción:
    </p>
    <pre><code class="language-haskell">freeVars :: Term -> Set.Set String
freeVars (Var s) = Set.singleton s
freeVars (Abs s t) = Set.delete s (freeVars t)
freeVars (App t1 t2) = Set.union (freeVars t1) (freeVars t2)</code></pre>
    <p>
      Para poder utilizar los conjuntos del preludio de <a href="    https://www.haskell.org/">Haskell</a>, es necesario importarlos, con por ejemplo: <code class="language-haskell">import qualified Data.Set as Set</code> al principio del fichero que contenga el código.
    </p>
    <pre><code class="language-haskell">module UntypedLambdaCalc where

import qualified Data.Set as Set

data Term = Var String
          | Abs String Term
          | App Term Term
          deriving (Eq, Ord, Show)

showTerm :: Term -> String
showTerm (Var s) = s
showTerm (Abs s t) = "(λ" ++ s ++ ". " ++ showTerm t ++ ")"
showTerm (App t1 t2) = (showTerm t1) ++ " " ++ (showTerm t2)

putTerm :: Term -> IO()
putTerm t = putStrLn (showTerm t)

allVars :: Term -> Set.Set String
allVars (Var s) = Set.singleton s
allVars (App t1 t2) = Set.union (allVars t1) (allVars t2)
allVars (Abs s t) = allVars t

freeVars :: Term -> Set.Set String
freeVars (Var s) = Set.singleton s
freeVars (App t1 t2) = Set.union (freeVars t1) (freeVars t2)
freeVars (Abs s t) = Set.delete s (freeVars t)

subTerms :: Term -> Set.Set Term
subTerms (Var s) = Set.singleton (Var s)
subTerms (App t1 t2) = Set.insert (App t1 t2) (Set.union (subTerms t1) (subTerms t2))
subTerms (Abs s t)   = Set.insert (Abs s t) (subTerms t)

capAvoidSubs :: Term -> String -> Term -> Term
capAvoidSubs same@(Var y) x n
  | y == x = n
  | otherwise = same
capAvoidSubs (App t1 t2) s t3 = App (capAvoidSubs t1 s t3) (capAvoidSubs t2 s t3)
capAvoidSubs (Abs y m) x n
  | y == x = (Abs y m)
  | otherwise = if Set.member y (freeVars n)
                then
                  let z = freshVar y (Set.union (freeVars m) (freeVars n))
                  in (Abs z (capAvoidSubs (capAvoidSubs m y (Var z)) x n))
                else
                  (Abs y (capAvoidSubs m x n))
  where
    freshVar :: String -> Set.Set String -> String
    freshVar s terms = if Set.member (s ++ "'") terms
                       then
                         freshVar (s ++ "'") terms
                       else
                         (s ++ "'")

betaRed :: Term -> Term
betaRed same@(Var x) = same
betaRed (Abs x y) = Abs x (betaRed y)
betaRed (App (Abs x y) z) = capAvoidSubs y x z
betaRed (App x y) = App (betaRed x) (betaRed y)

nStepBetaRed :: Term -> Integer -> Term
nStepBetaRed t 0 = t
nStepBetaRed t n = nStepBetaRed (betaRed t) (n-1)

isRedex :: Term -> Bool
isRedex same@(Var x) = False
isRedex (Abs x y) = isRedex y
isRedex (App (Abs x y) z) = True
isRedex (App x y) = isRedex x || isRedex y

infBetaRed :: Term -> Term
infBetaRed t = if isRedex t
               then
                 infBetaRed (betaRed t)
               else
                 t

printStepByStep :: Term -> IO ()
printStepByStep t = do
  putTerm t
  if isRedex t
    then printStepByStep (betaRed t)
    else return ()

printNStepByStep :: Term -> Integer -> IO ()
printNStepByStep t 0 = putTerm t
printNStepByStep t n = do
  putTerm t
  printNStepByStep (betaRed t) (n-1)
    
identity = Abs "x" (Var "x")
true = Abs "t" (Abs "f" (Var "t"))
false = Abs "t" (Abs "f" (Var "f"))
if_ = Abs "b" (Abs "x" (Abs "y" (App (App (Var "b") (Var "x")) (Var "y"))))
testIfTrue = (App (App (App if_ true) (Var "THEN")) (Var "ELSE"))
testIfFalse = (App (App (App if_ false) (Var "ELSE")) (Var "ELSE"))
zero = Abs "f" (Abs "x" (Var "x"))
succ_ = Abs "n" (Abs "f" (Abs "x" (App (Var "f") (App (App (Var "n") (Var "f")) (Var "x")))))
churchNumeral :: Integer -> Term
churchNumeral n = infBetaRed (churchNumeral_ n)
  where churchNumeral_ 0 = zero
        churchNumeral_ n = betaRed (App succ_ (churchNumeral_ (n-1)))
plus = Abs "m" (Abs "n" (Abs "f" (Abs "x" (App (App (Var "m") (Var "f")) (App (App (Var "n") (Var "f")) (Var "x"))))))
mult = Abs "m" (Abs "n" (Abs "f" (App (Var "m") (App (Var "n") (Var "f")))))
omega = App (Abs "x" (App (Var "x") (Var "x"))) (Abs "x" (App (Var "x") (Var "x")))
ycomb = Abs "f" (App (Abs "x" (App (Var "f") (App (Var "x") (Var "x")))) (Abs "x" (App (Var "f") (App (Var "x") (Var "x")))))
zeta  = Abs "f" (App (Abs "x" (App (Var "f") (Abs "v" (App (App (Var "x") (Var "x")) (Var "v"))))) (Abs "x" (App (Var "f") (Abs "v" (App (App (Var "x") (Var "x")) (Var "v"))))))
turing = Abs "x" (App (Abs "y" (App (Var "x") (Abs "z" (App (App (Var "y") (Var "y")) (Var "z"))))) (Abs "y" (App (Var "x") (Abs "z" (App (App (Var "y") (Var "y")) (Var "z"))))))
    </code></pre>
    <h2 style="color: #000;">Contacto</h2>
    <p>
      GitHub: <a href="https://github.com/laredo02">github.com/laredo02</a><br>
      LinkedIn: <a href="https://www.linkedin.com/in/miguel-laredo">linkedin.com/in/miguel-laredo</a><br>
      Telegram: <a href="https://t.me/laredo02">https://t.me/laredo02</a><br>
    </p>
    <hr style="border: 1px solid #ecf0f1;">
    <footer style="text-align: center; margin-top: 20px;">
      <p>&copy; 2024 Miguel Laredo. Este proyecto está bajo la Licencia Pública General GNU (GPL)</p>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>
