
<!DOCTYPE html>

<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Miguel Laredo</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css" rel="stylesheet"/>
</head>

<meta name="Miguel Laredo" content="Miguel Laredo"> 

<body style="font-family: 'Georgia', serif; max-width: 1200px; margin: 0 auto; padding: 20px; line-height: 1.6; text-align: justify; color: #000;">













  
<h1 style="text-align: center; border-bottom: 2px solid #000; padding-bottom: 10px; color: #000;">Miguel Laredo Barbadillo</h1>

<h2 style="text-align: center; color: #000;">Sobre Mí</h2>
<p> 
  Soy Miguel Laredo, estudiante de máster en Métodos Formales, con interés en la informática teórica y las matemáticas. Fuera del ámbito académico, me gusta la papiroflexia, los deportes de resistencia (natación, triatlón, esquí de montaña...) y aprender lo que sea.
</p>














<h2 style="text-align: center; color: #000;">Sobre guiverno</h2>
<p>
  
  El nombre del blog está inspirado por el icónico <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools"><em>Dragon Book</em></a> de Aho, Lam, Sethi y Ullman. Es un libro bastante conocido en el mundillo de los compiladores. En la portada tiene un caballero enfrentándose a un dragón, supongo que simboliza la lucha por conquistar la complejidad o algo así.

  Creo que también existe una cierta analogía entre lo que representan el caballero y el dragón en la portada del <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools"><em>Dragon Book</em></a> y lo que representan Satanás y San Miguel en el Juicio Final. Tal vez esto sea un poco columpiada, pero creo que son las versiones moral/teológica y técnica/práctica de la misma historia.


<div style="text-align: center;">
    <img src="rsc/purple-dragon-book.jpg" alt="Imagen 1" style="height: 400px; width: auto; margin: 10px;">
    <img src="rsc/san-miguel.jpeg" alt="Imagen 2" style="height: 400px; width: auto; margin: 10px;">
</div>








</p>

<h2 style="text-align: center; color: #000;">Papiroflexia</h2>

<p>
  De vez en cuando me vuelve a dar por hacer papiroflexia. Es una de las actividades que conservo desde que tengo como cinco o seis años. Dejo aquí abajo algunas interpretaciones mías de figuras de autor que me gustan. La primera de todas es la migale de Manuel Sirgo, un modelo que guardo a buen recaudo desde hace unos once años y al cual tengo mucho cariño a pesar de estar ya un poco maltratado por el tiempo ya que marcó un antes y un después en la forma en que pliego. Supongo que tendría unos diez u once años por aquel entonces, pero recuerdo claramente que ya fabricaba mi propio papel sandwich. 
</p>

<div style="text-align: center;">
    <img src="rsc/migale-manuel-sirgo.jpeg" alt="Imagen 1" style="height: 400px; width: auto; margin: 10px;">
    <img src="rsc/migale-manuel-sirgo2.jpeg" alt="Imagen 2" style="height: 400px; width: auto; margin: 10px;">
</div>

<p>
  Otro clásico que me encanta es el toro de Gabriel Alvarez, un socio de la Asociación Española de Papiroflexia. Creo que Manuel, el dueño de Minimum, le conoce. Me parece un modelo sólido, a pesar de ser bastante sencillo, captura muy bien la esencia del toro. Tanto en la postura como las proporciones y las formas. También hay que decir que me ha costado bastante pillarle el truco a cómo plegar bien la cabeza para no fastidiar la morfología del resto de la pieza.
</p>

<div style="text-align: center;">
    <img src="rsc/toro-gabriel-alvarez.jpg" alt="Toro de Gabriel Álvarez" style="max-width: 30%; height: auto; display: block; margin: auto;">
</div> 



<h2 style="text-align: center; color: #000;">Algunas Cosas Sobre Programación</h2>

Estoy terminando un intérprete de expresiones lambda escrito en Haskell para subir aquí, ya tengo el soporte del lambda calculo no tipado. Tengo que ver si desarrollo también una version con tipado simple y contemplar si añadir tipos dependientes y paramétricos en el futuro. Para ver mis proyectos personales, mejor dirígete a <a href="https://github.com/laredo02" style="color: #3498db;">github.com/laredo02</a>. Aquí prefiero subir programas autocontenidos a modo de curiosidad más que explicaciones en profundidad de temas extensos. Mientras no tenga nada mejor, mantendré la implementación del mandelbrot, que funciona, a pesar de ser un poco cochambrosa.




<h2 style="text-align: center; color: #000;">Mandelbrot</h2>

    <p>El conjunto de Mandelbrot es un fractal matemático definido en el plano complejo mediante la iteración:</p>

    <p style="text-align: center;">\[
    z_{n+1} = z_n^2 + c
    \]</p>

    <p>donde \( z_0 = 0 \) y \( c \) es un número complejo. La clave está en determinar si la sucesión \(\{z_n\}\) diverge o permanece acotada.</p>

    <p>Para clasificar un número complejo \( c \):</p>

    <ul>
        <li>Empezamos con \( z_0 = 0 \).</li>
        <li>Iteramos \( z_{n+1} = z_n^2 + c \).</li>
        <li>Si \( |z_n| \) supera 2 en algún momento, \(c\) queda fuera del conjunto. Si se mantiene acotado, pertenece al conjunto.</li>
    </ul>

    <p>En CUDA, la <code>std::complex</code> no funciona en GPU. La solución: definir una clase compleja personalizada con calificadores <code>__host__</code> y <code>__device__</code>.</p>

  
<pre><code class="language-c++">
#pragma once

namespace cum {

    struct Complex {
        float real;
        float imag;

        __host__ __device__ Complex(float real = 0.0f, float imag = 0.0f) : real(real), imag(imag) {}

        __host__ __device__ float magnitude() const {
            return sqrtf(real * real + imag * imag);
        }

        __host__ __device__ Complex operator+(const Complex &b) const {
            return Complex(real + b.real, imag + b.imag);
        }

        __host__ __device__ Complex operator*(const Complex &b) const {
            return Complex(real * b.real - imag * b.imag, real * b.imag + imag * b.real);
        }

    };

}
</code></pre>


<pre><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;cuda_runtime.h&gt;

#include "Image.hpp"
#include "Complex.cuh"

// Función de mapeo para escalar el valor de profundidad a un rango de 0 a 255
__host__ __device__ int map(int value, int imin, int imax, int fmin, int fmax) {
    return (int) ((float)value / (imax - imin)) * ((float)fmax - fmin);
}

// Kernel para calcular el conjunto de Mandelbrot
__global__ void mandelbrot(int* grid, int width, int height, cum::Complex leftop, cum::Complex rightbot, int max_depth) {
    int x = blockDim.x * blockIdx.x + threadIdx.x;
    int y = blockDim.y * blockIdx.y + threadIdx.y;
    
    if (x < width && y < height) {
        double xstep = (rightbot.real - leftop.real) / (float)width;
        double ystep = (leftop.imag - rightbot.imag) / (float)height;
        double xcoord = leftop.real + x * xstep;
        double ycoord = leftop.imag - y * ystep;
        
        cum::Complex z(0.0f, 0.0f);
        cum::Complex c(xcoord, ycoord);
        
        int depth = 0;
        while (z.magnitude() <= 2.0f && depth < max_depth) {
            z = z * z + c;
            depth++;
        }
        
        int value = map(depth, 0, max_depth, 0, 255);
        grid[y * width + x] = value;
    }
}

int main() {
    int width = 3840;
    int height = 2160;
    double aspect_ratio = width / (double)height;
    
    double w = 7.0;
    
    cum::Complex size(w, w * (1 / aspect_ratio));
    cum::Complex center(0.0, 0.0);
    cum::Complex leftop(center.real - size.real / 2.0, center.imag + size.imag / 2.0);
    cum::Complex rightbot(center.real + size.real / 2.0, center.imag - size.imag / 2.0);
    
    int max_depth = 1000;
    
    int* grid;
    cudaMallocManaged(&grid, sizeof(int) * width * height);
    
    dim3 threads(16, 16);  // Definir un número más razonable de hilos por bloque
    dim3 blocks((width + threads.x - 1) / threads.x, (height + threads.y - 1) / threads.y);
    
    mandelbrot&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(grid, width, height, leftop, rightbot, max_depth);
    cudaDeviceSynchronize();
    
    cum::Image img(width, height);
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            int value = grid[y * width + x];
            img.setPixel(x, y, value, value, value);
        }
    }
    
    img.save("image.ppm");
    
    cudaFree(grid);
    
    return 0;
}
</code></pre>





<h2 style="color: #000;">Contacto</h2>
<p>
GitHub: <a href="https://github.com/laredo02" style="color: #3498db;">github.com/laredo02</a><br>
LinkedIn: <a href="https://www.linkedin.com/in/miguel-laredo" style="color: #3498db;">linkedin.com/in/miguel-laredo</a><br>
Telegram: <a href="https://t.me/laredo02" style="color: #3498db;">https://t.me/laredo02</a><br>
</p>




<hr style="border: 1px solid #ecf0f1;">

<footer style="text-align: center; margin-top: 20px; color: #7f8c8d;">
<p>&copy; 2024 Miguel Laredo. Todos los derechos reservados.</p>
</footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>


    
</body>
</html>





